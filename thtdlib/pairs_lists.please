(define (list . args) args)

(define (list-rev l)
  (if (> (list-len l) 1)
    (extend (list-rev (cdr l)) (car l))
    l))

(define (list-len l)
  (fold (lambda (acc _) (add1 acc)) 0 l))

(define (append1 l x) 
  (if l
    (lazy-cons (car l) (append1 (cdr l) x))
    x))

(define (append . lists)
  (if lists
    (append1 (car lists) (apply append (cdr lists)))
    '()))

(define (extend l . rest) (append l rest)) ; auto-list

(define (list-nth l n)
  (if (<=0 n)
    (car l)
    (list-nth (cdr l) (sub1 n))))

(define (first l)   (car l))
(define (second l)  (list-nth l 1))
(define (third l)   (list-nth l 2))
(define (fourth l)  (list-nth l 3))
(define (fifth l)   (list-nth l 4))
(define (sixth l)   (list-nth l 5))
(define (seventh l) (list-nth l 6))
(define (eighth l)  (list-nth l 7))
(define (ninth l)   (list-nth l 8))
(define (tenth l)   (list-nth l 9))

(define (list-empty? l) (=0 (list-len l))) ; this is just `null?` w/e
(define list-!empty? (~ list-empty?)) 

; Return the first `n` elements of `l`
(define (take n l) 
  (if (<=0 n)
    ()
    (lazy-cons (car l) (take (sub1 n) (cdr l)))))

; Skip the first `n` elements of `l`
(define (leave n l)
  (if (<=0 n)
    l
    (leave (sub1 n) (cdr l))))
(define drop leave) ; alwinfy's no fun

; Omit the nth element of l
(define (omit n l) 
  (let ([split (split-at n l)])
    (append (car split) (cdr split))))

(define (split-at n l) (cons (take n l) (leave (add1 n) l)))

(define (find needle haystack [equal? equal?]) 
  (let searcher ([n 0] [haystack haystack])
    (cond
      [(not haystack) false]
      [(equal? needle (car haystack)) n]
      (searcher (add1 n) (cdr haystack)))))

;; Returns (head . tail) around the element requested,
;; or false if it isn't found.
(define (split-around needle haystack [equal? equal?])
  (let ([n (find needle haystack equal?)])
    (and n (split-at n haystack))))

(define (last l)
  (if (null? (cdr l))
    (car l)
    (last (cdr l))))

(define (flatten l) 
  (and l
    (if (list? (car l))
      (append (car l) (flatten (cdr l)))
      (cons (car l) (flatten (cdr l))))))

(define (riap x) (cons (cdr x) (car x)))

(define (splice n surrounder inner)
  (append (take n surrounder) inner (leave n surrounder)))

(define (range [start 'never] [end false])
  (if end
    (let loop ([n start])
      (if (or (equal? end 'never) (< n end))
        (lazy-cons n (loop (add1 n)))
        ()))
    (range 0 start)))

; Unlazy range which i needed
(define (range-direct start end)
  (let loop ([n (sub1 end)] [acc ()])
    (if (< n start) 
      acc
      (loop (sub1 n) (cons n acc)))))

(define (chunks n l)
  (let loop ([len (list-len l)] [l l])
    (if (>= len n)
      (cons (take n l) (loop (- len n) (leave n l)))
      (and l l (cons l ())))))

; mergesort
; https://stackoverflow.com/questions/36193383/difficulty-writing-lisp-recursive-function-for-merge-sort
(define (sort l [< <])
  (and l (if (nil? (cdr l)) l
    (let (
      [merge-lists (\ (l1 l2) (cond
        [(and (nil? l1) (nil? l2)) ()]
        [(nil? l1) (cons (car l2) (merge-lists () (cdr l2)))]
        [(nil? l2) (cons (car l1) (merge-lists (cdr l1) ()))]
        [(< (car l1) (car l2)) (cons (car l1) (merge-lists (cdr l1) l2))]
        (cons (car l2) (merge-lists l1 (cdr l2)))))]
      [s (chunks 1 l)]
      [x (sort (car s))]
      [y (sort (cadr s))])
      (merge-lists x y)))))
