; Composing and mapping functions

(define (for fn list)
  (if list
    (lazy-cons (fn (car list)) (for fn (cdr list)))
    ()))

(define (fold fn acc . lists)
  (if (all (~ null?) lists)
    ; still have leftover list
    (apply fold fn
      (apply fn acc (for car lists))
      (for cdr lists))
    ; we're done, give the acc
    acc))

(define (map fn . rows)
  (if (all (~ null?) rows)
    (lazy-cons (apply fn (for car rows)) (apply map fn (for cdr rows)))
    ()))

(define (filter fn list)
  (and list
    (if (fn (car list))
      ; it passes, put the original on and cons on the rest
      (lazy-cons (car list) (filter fn (cdr list)))
      ; ignore and just pass the rest
      (filter fn (cdr list)))))

(define (compose fn . rest)
  (if rest
    (\ (x)
      ; execute fn on ((the rest of the composed functions) of x)
      (fn ((apply compose rest) x)))
    fn))

(define (identity x) x) ; man that was hard

(define (const it) (\ _ it))

(define (negate fn) (\ (x) (not (fn x))))

(define (conjoin . fs) 
  (\ xs 
    (all (curryr apply xs) fs)))

(define (disjoin . fs) 
  (\ xs 
    (any (curryr apply xs) fs)))

(define (juxt . fs)
  (\ xs
    (for (curryr apply xs) fs)))

(define (curry fn . args)
  (lambda newargs
    (apply fn (append args newargs))))
(define partial curry)

(define (curryr fn . args)
  (lambda newargs
    (apply fn (append newargs args))))

;*
(define-macro (brooks . body)
  (let (
    [flankers (split-around '_ body)])
    (cond
      ; put the threadee between the flankers
      [flankers `(\ newargs (eval 
        (append ; both are lists  
          (append ',(car flankers) newargs) ; append because newargs is a list
          ',(cdr flankers))))]
      ; put the threadee after the first argument (the function, probably)
      [true `(\ newargs (eval
        (cons 
          ',(car body) 
          (cons newargs ',(cdr body)))))])))
*;

(define (all fn list) 
  (if list
    (and (fn (car list)) (all fn (cdr list)))
    true))

(define (any fn list) 
  (if list
    (or (fn (car list)) (all fn (cdr list)))
    false))

(define-macro (thunk . bodies) `(\ () . ,bodies))

(define \ lambda)
(define fn lambda)
(define-macro (\@ . bodies) `(lambda (@) ,bodies))

(define (range [start 'never] [end false])
  (if end
    (let loop ([n start])
      (if (or (equal? end 'never) (< n end))
        (lazy-cons n (loop (add1 n)))
        ()))
    (range 0 start)))
