; Composing and mapping functions

(define (compose fn . rest)
  (if rest
    (\ (x)
      ; execute fn on ((the rest of the composed functions) of x)
      (fn ((apply compose rest) x)))
    fn))

(define (identity x) x) ; man that was hard

(define (const it) (\ _ it))

(define (negate fn) (\ x (not (apply fn x))))

(define (conjoin . fs) 
  (\ xs 
    (all (curryr apply xs) fs)))

(define (disjoin . fs) 
  (\ xs 
    (any (curryr apply xs) fs)))

(define (juxt . fs)
  (\ xs
    (for (curryr apply xs) fs)))

(define (curry fn . args)
  (lambda newargs
    (apply fn (append args newargs))))
(define partial curry)

(define (curryr fn . args)
  (lambda newargs
    (apply fn (append newargs args))))

(define (all fn list) 
  (if list
    (and (fn (car list)) (all fn (cdr list)))
    true))

(define (any fn list) 
  (if list
    (or (fn (car list)) (any fn (cdr list)))
    false))

(define-macro (thunk . bodies) `(\ () . ,bodies)) ; require zero args
(define-macro (thunk* . bodies) `(\ _ . ,bodies)) ; allow any args

(define \ lambda)
(define fn lambda)
(define-macro (\@ . bodies) `(lambda (@) . ,bodies))

(define (always? . _) true)
(define (never? . _) false)

(define (argc x) 
  (let ([args (first (open-procedure x))])
    ; If the arguments are *not* a proper list it's a vararg function
    (if (list? args)
      (list-len args)
      'inf)))

(define-macro (macro-expand m)
  (apply-no-expand (car m) (cdr m)))
