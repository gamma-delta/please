; Composing and mapping functions

(defun compose (fn . rest)
  (if rest
    (\ (x)
      ; execute fn on ((the rest of the composed functions) of x)
      (fn ((apply compose rest) x)))
    fn))

(defun identity (x) x) ; man that was hard

(defun const (it) (\ _ it))

(defun negate (fn) (\ x (not (apply fn x))))

(defun conjoin (. fs) 
  (\ xs 
    (all (curryr apply xs) fs)))

(defun disjoin (. fs) 
  (\ xs 
    (any (curryr apply xs) fs)))

(defun juxt (. fs)
  (\ xs
    (for (curryr apply xs) fs)))

(defun curry (fn . args)
  (lambda newargs
    (apply fn (append args newargs))))
(define partial curry)

(defun curryr (fn . args)
  (lambda newargs
    (apply fn (append newargs args))))

(defun all (fn list) 
  (if list
    (and (fn (car list)) (all fn (cdr list)))
    true))

(defun any (fn list) 
  (if list
    (or (fn (car list)) (any fn (cdr list)))
    false))

(define-macro thunk (. bodies) `(\ () . ,bodies)) ; require zero args
(define-macro thunk* (. bodies) `(\ _ . ,bodies)) ; allow any args

(define \ lambda)
(define fn lambda)
(define-macro \@ (. bodies) `(lambda (@) . ,bodies))

(defun always? (. _) true)
(defun never? (. _) false)

(defun argc (x) 
  (let ([args (first (open-procedure x))])
    ; If the arguments are *not* a proper list it's a vararg function
    (if (list? args)
      (list-len args)
      'inf)))
