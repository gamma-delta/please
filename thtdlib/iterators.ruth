; Iteration and higher-order functions.

; alwinfy, for should not be lazy ...
(define (for fn list)
  (if list
    (cons (fn (car list)) (for fn (cdr list)))
    ()))

(define (fold fn acc . lists)
  (if (all (~ null?) lists)
    ; still have leftover list
    (apply fold fn
      (apply fn acc (for car lists))
      (for cdr lists))
    ; we're done, give the acc
    acc))

(define (map fn . rows)
  (if (all (~ null?) rows)
    (lazy-cons (apply fn (for car rows)) (apply map fn (for cdr rows)))
    ()))

(define (filter fn list)
  (and list
    (if (fn (car list))
      ; it passes, put the original on and cons on the rest
      (lazy-cons (car list) (filter fn (cdr list)))
      ; ignore and just pass the rest
      (filter fn (cdr list)))))

(define (filter-map fn . rows)
  (if (all (~ null?) rows)
    (let (
      [res (apply fn (for car rows))]
      [rest (thunk (apply filter-map fn (for cdr rows)))])
      (if res
        (lazy-cons res (rest))
        (rest)))
    ()))

(define (flat-map f l)
  (apply append (for f l)))

(define (mult1 l r)
  (flat-map (\ (l) (for (\ (r) (cons r l)) r)) l))

(define (mult lists)
  (fold mult1 '(()) lists))

(define (repeat elt [max false])
  (if max
    (if (>=0 max)
      (lazy-cons elt (repeat elt (sub1 max)))
      ())
  (lazy-cons elt (repeat elt))))

; Force-eval the first n elements of the lazy list
(define (reify n l)
  (if (>=0 n)
    (cons (car l) (reify (sub1 n) (cdr l)))
    l))

(define (find-map fn . rows)
  (if (all (~ null?) rows)
    (or (apply fn (for car rows)) (apply find-map fn (for cdr rows)))
    false))
