; Composing and mapping functions

;*
X map
X filter
X compose
X identity
X const
X negate
X conjoin
X disjoin
X juxt
*;

(define (for fn list)
  (if list
    (lazy-cons (fn (car list)) (for fn (cdr list)))
    ()))

(define (fold fn acc . lists)
  (if lists
    ; still have leftover list
    (fold fn
      (apply fn acc (for car lists))
      (for cdr lists))
    ; we're done, give the acc
    acc))

(define (map fn . rows)
  (if (apply and rows)
    (lazy-cons (apply fn (for rows car)) (apply map fn (for rows cdr)))
    ())))

(define (filter fn list)
  (and list
    (if (fn (car list))
      ; it passes, put the original on and cons on the rest
      (lazy-cons (car list) (filter fn (cdr list))
      ; ignore and just pass the rest
      (filter fn (cdr list))))))

(define-macro (compose fn . rest)
  `(apply lambda-> ,(append (list-rev rest) fn)))

(define (identity x) x) ; man that was hard

(define (const it) (\ _ it))

(define (negate fn) (\ (x) (not (fn x))))

(define (conjoin . fs) 
  (\ xs 
    (all fs (\ (fn) (apply fn xs)))))

(define (disjoin . fs) 
  (\ xs 
    (any fs (\ (fn) (apply fn xs)))))

(define (juxt . fs)
  (\ xs
    (for fs (\ (fn) (apply fn xs)))))

(define (curry fn . args)
  (lambda newargs
    (apply fn (append args newargs))))
(define partial curry)

(define (all fn list) 
  (if list
    (and (fn (car list)) (all fn (cdr list)))
    true))

(define (any fn list) 
  (if list
    (or (fn (car list)) (all fn (cdr list)))
    false))

(define-macro (thunk . bodies) `(\ () . ,bodies))

(define \ lambda)
(define fn lambda)

(define (range start [end false])
  (if end
    (let loop ([n start])
      (if (< n end)
        (lazy-cons n (loop (add1 n)))
        ()))
    (range 0 start)))
